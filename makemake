#!/usr/bin/perl
#-
# Copyright (c) 2004-2005 FreeBSD GNOME Team <freebsd-gnome@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $Id: makemake,v 1.22 2005/06/08 02:25:55 marcus Exp $
#

use strict;
use TinderboxDS;
use Getopt::Std;
use vars qw(
    $BUILD
    $BUILD_NAME
    $JAIL
    $JAIL_NAME
    $PORTSTREE
    $PORTSTREE_NAME
    @PORTS
    $BUILD_ROOT
    $PORTBUILD
);

require "tinderbox.ph";    # Setup the tinderbox config.
require "tinderlib.pl";

# Get a database handle for obtaining the ports.
my $ds          = new TinderboxDS();
my @build_names = $ds->getAllBuilds();
if (!defined(@build_names) && defined($ds->getError())) {
        cleanup($ds, 1,
                "Failed to get list of jails: " . $ds->getError() . "\n");
} elsif (!defined(@build_names)) {
        cleanup($ds, 1, "There are no builds configured in this tinderbox\n");
}
if (scalar(@ARGV) < 1) {
        print STDERR "usage: $0 [-n] <build name> [<port directory> ...]\n";
        print STDERR "Current builds are:\n";
        foreach (@build_names) {
                print STDERR "\t" . $_->getName() . "\n";
        }
        cleanup($ds, 1, undef);
}

my $noduds  = 0;
my $opts    = {};
my @flarr   = ();
my $pbflags = "";

getopts('n', $opts);

if ($opts->{'n'}) {
        $noduds = 1;
}

if (defined($ENV{'NOCLEAN'})) {
        push @flarr, "-noclean";
}
if (defined($ENV{'PLISTCHECK'})) {
        push @flarr, "-plistcheck";
}
if (defined($ENV{'NULLFS'})) {
        push @flarr, "-nullfs";
}

$pbflags = join(" ", @flarr);

@PORTS = ();
$BUILD = $ds->getBuildByName($ARGV[0]);
if (!$BUILD) {
        cleanup($ds, 1, "Unknown build, \"$ARGV[0]\"\n");
}
$BUILD_NAME = $BUILD->getName();
shift @ARGV;

$JAIL           = $ds->getJailForBuild($BUILD);
$JAIL_NAME      = $JAIL->getName();
$PORTSTREE      = $ds->getPortsTreeForBuild($BUILD);
$PORTSTREE_NAME = $PORTSTREE->getName();

buildenv($BUILD_ROOT, $BUILD_NAME, $JAIL_NAME, $PORTSTREE_NAME);

delete $ENV{'DISPLAY'};

# Set LOCALBASE, X11BASE, PKGDB_DIR, and LINUXBASE to bogus values to prevent
# system installed packages from affecting the tinderbox.
$ENV{'LOCALBASE'}  = "/nonexistentlocal";
$ENV{'X11BASE'}    = "/nonexistentx";
$ENV{'PKG_DBDIR'}  = "/nonexistentdb";
$ENV{'PORT_DBDIR'} = "/nonexistentportdb";
$ENV{'LINUXBASE'}  = "/nonexistentlinux";

if (!scalar(@ARGV)) {
        my @dsPorts = $ds->getPortsForBuild($BUILD);
        if (!defined(@dsPorts)) {
                cleanup($ds, 1,
                              "Failed to get port information: "
                            . $ds->getError()
                            . "\n");
        }

        push @PORTS, @dsPorts;

} else {
        foreach my $arg (@ARGV) {
                my $port = $ds->getPortByDirectory($arg);
                if (!$port) {

                        # Simply create a sparse port with just a directory.
                        # If the port doesn't exist in the datastore, that's
                        # okay.
                        $port = new Port();
                        $port->setDirectory($arg);
                        push @PORTS, $port;
                } else {
                        push @PORTS, $port
                            if $ds->isPortForBuild($port, $BUILD);
                }
        }
}
my (%pkgdir, %pkgdeps, %rundepscache, @duds);
while (scalar(@PORTS)) {
        my $port    = shift @PORTS;
        my $portdir = $port->getDirectory();
        my ($pkgname, $deplist, $tportdir, @deps);

        next if (defined($pkgdir{$portdir}));

        $tportdir = $ENV{'PORTSDIR'} . "/" . $portdir;
        if (!-d $tportdir) {
                print STDERR "ERROR: Directory $tportdir does not exist.\n";
                if (defined($pkgdeps{$portdir})
                        && scalar(@{$pkgdeps{$portdir}}))
                {
                        print STDERR "ERROR: It is referenced by "
                            . (join(" ", @{$pkgdeps{$portdir}})) . "\n";
                }
                cleanup($ds, 1, undef);
        }
        $pkgname = `cd $tportdir && make -V PKGNAME`;
        chomp $pkgname;

        # Create a list of duds (ports that will not be attempted because they
        # are marked IGNORE or FORBIDDEN).
        if (!$noduds) {
                my $dudpkg = `cd $tportdir && make ignorelist ECHO_MSG=true`;
                if ($dudpkg) {
                        chomp $dudpkg;
                        push @duds, $dudpkg;
                }
        }

        $pkgdeps{$portdir} = [];
        $pkgdir{$portdir}  = $pkgname;
        my @deps = ();
        push @deps, getBuildDepends($tportdir);
        push @deps, getRunDepends($tportdir, \%rundepscache);
        foreach my $dep (@deps) {
                my %seen = ();
                chomp $dep;
                my @rundeps = getRunDepends($dep);
                while (scalar(@rundeps)) {
                        my $rundep = shift @rundeps;
                        chomp $rundep;
                        next if (defined($seen{$rundep}));
                        push @rundeps, getRunDepends($rundep, \%rundepscache);
                        $seen{$rundep}++;
                        $rundep =~ s|^$ENV{'PORTSDIR'}/||;
                        push @{$pkgdeps{$portdir}}, $rundep;
                }
                $dep =~ s|^$ENV{'PORTSDIR'}/||;
                push @{$pkgdeps{$portdir}}, $dep;
                my $p = new Port();
                $p->setDirectory($dep);
                push @PORTS, $p;
        }
}
my $makefile = join("/", $BUILD_ROOT, "builds", $BUILD_NAME, "Makefile");
unless (open(MK, ">" . $makefile)) {
        cleanup($ds, 1, "Failed to open $makefile for writing: $!\n");
}
foreach my $key (keys %pkgdir) {
        my @depsarr      = @{$pkgdeps{$key}};
        my %seen         = ();
        my @depsarrclean = grep { !$seen{$_}++ } @depsarr;
        my @deppkgnames = map { $pkgdir{$_} . $ENV{'PKGSUFFIX'} } @depsarrclean;
        print MK "all: $pkgdir{$key}$ENV{'PKGSUFFIX'}\n";
        print MK "$pkgdir{$key}: $pkgdir{$key}$ENV{'PKGSUFFIX'}\n";
        print MK "$pkgdir{$key}$ENV{'PKGSUFFIX'}: "
            . join(" ", @deppkgnames) . "\n";
        print MK
            "\t\@$PORTBUILD $BUILD_NAME $JAIL_NAME $PORTSTREE_NAME $pbflags $pkgdir{$key}$ENV{'PKGSUFFIX'} /usr/ports/$key "
            . join(" ", @deppkgnames) . "\n";
}
close(MK);

my $dudsfile = join("/", $BUILD_ROOT, "builds", $BUILD_NAME, "duds");
unlink($dudsfile);

if (!$noduds) {
        unless (open(DUDS, ">" . $dudsfile)) {
                cleanup($ds, 1, "Failed to open $dudsfile for writing: $!\n");
        }
        foreach my $dud (sort @duds) {
                print DUDS $dud . "\n";
        }

        close(DUDS);
}

# Now, symlink the Makefile to the correct All directory.
system("mkdir -p $BUILD_ROOT/packages/$BUILD_NAME/All");
unlink "$BUILD_ROOT/packages/$BUILD_NAME/All/Makefile";
symlink $makefile, "$BUILD_ROOT/packages/$BUILD_NAME/All/Makefile";

cleanup($ds, 0, undef);

sub getBuildDepends {
        my $portdir = shift;

        return _getDepends($portdir, "build-depends-list");
}

sub getRunDepends {
        my $portdir      = shift;
        my $rundepscache = shift;

        if (defined($rundepscache) && defined($rundepscache->{$portdir})) {
                return @{$rundepscache->{$portdir}};
        }

        my @deps = _getDepends($portdir, "run-depends-list");
        $rundepscache->{$portdir} = \@deps;

        return @deps;
}

sub _getDepends {
        my $portdir = shift;
        my $target  = shift;

        my @deplist = `cd $portdir && make $target`;

        return @deplist;
}
