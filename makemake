#!/usr/bin/perl
#-
# Copyright (c) 2004 FreeBSD GNOME Team <freebsd-gnome@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $Id$
#


use strict;
use TinderboxDS;
use vars qw(
    $BUILD
    $BUILD_NAME
    $JAIL
    $JAIL_NAME
    $PORTSTREE
    $PORTSTREE_NAME
    @PORTS
    $BUILD_ROOT
    $PORTBUILD
);

require "tinderbox.ph";    # Setup the tinderbox config.
require "tinderlib.pl";

# Get a database handle for obtaining the ports.
my $ds          = new TinderboxDS();
my @build_names = $ds->getAllBuilds();
if (!defined(@build_names) && defined($ds->getError())) {
        cleanup($ds, 1,
                "Failed to get list of jails: " . $ds->getError() . "\n");
} elsif (!defined(@build_names)) {
        cleanup($ds, 1, "There are no builds configured in this tinderbox\n");
}
if (scalar(@ARGV) < 1) {
        print STDERR "usage: $0 <build name> [<port directory> ...]\n";
        print STDERR "Current builds are:\n";
        foreach (@build_names) {
                print STDERR "\t" . $_->getName() . "\n";
        }
        cleanup($ds, 1, undef);
}

@PORTS = ();
$BUILD = $ds->getBuildByName($ARGV[0]);
if (!$BUILD) {
        cleanup($ds, 1, "Unknown build, \"$ARGV[0]\"\n");
}
$BUILD_NAME = $BUILD->getName();
shift @ARGV;

$JAIL           = $ds->getJailForBuild($BUILD);
$JAIL_NAME      = $JAIL->getName();
$PORTSTREE      = $ds->getPortsTreeForBuild($BUILD);
$PORTSTREE_NAME = $PORTSTREE->getName();

buildenv($BUILD_ROOT, $BUILD_NAME, $JAIL_NAME, $PORTSTREE_NAME);

# Set LOCALBASE and X11BASE to bogus values to prevent system installed
# packages from affecting the tinderbox.
$ENV{'LOCALBASE'} = "/nonexistentlocal";
$ENV{'X11BASE'}   = "/nonexistentx";

if (!scalar(@ARGV)) {
        my @dsPorts = $ds->getPortsForBuild($BUILD);
        if (!defined(@dsPorts)) {
                cleanup($ds, 1,
                              "Failed to get port information: "
                            . $ds->getError()
                            . "\n");
        }

        push @PORTS, @dsPorts;

} else {
        foreach my $arg (@ARGV) {
                my $port = $ds->getPortByDirectory($arg);
                if (!$port) {

                        # Simply create a sparse port with just a directory.
                        # If the port doesn't exist in the datastore, that's
                        # okay.
                        $port = new Port();
                        $port->setDirectory($arg);
                        push @PORTS, $port;
                } else {
                        push @PORTS, $port
                            if $ds->isPortForBuild($port, $BUILD);
                }
        }
}
my (%pkgdir, %pkgdeps);
while (scalar(@PORTS)) {
        my $port    = shift @PORTS;
        my $portdir = $port->getDirectory();
        my ($pkgname, $deplist, $tportdir, @deps);

        next if (defined($pkgdir{$portdir}));

        $tportdir = $ENV{'PORTSDIR'} . "/" . $portdir;
        if (!-d $tportdir) {
                print STDERR "ERROR: Directory $tportdir does not exist.\n";
                if (defined($pkgdeps{$portdir})
                        && scalar(@{$pkgdeps{$portdir}}))
                {
                        print STDERR "ERROR: It is referenced by "
                            . (join(" ", @{$pkgdeps{$portdir}})) . "\n";
                }
                cleanup($ds, 1, undef);
        }
        $pkgname = `cd $tportdir && make -V PKGNAME`;
        chomp $pkgname;

        $pkgdeps{$portdir} = [];
        $pkgdir{$portdir}  = $pkgname;
        $deplist           = `cd $tportdir && make all-depends-list`;
        chomp $deplist;
        @deps = split(/\n/, $deplist);
        foreach my $dep (@deps) {
                $dep =~ s|^$ENV{'PORTSDIR'}/||;
                push @{$pkgdeps{$portdir}}, $dep;
                my $p = new Port();
                $p->setDirectory($dep);
                push @PORTS, $p;
        }
}
my $makefile = join("/", $BUILD_ROOT, "builds", $BUILD_NAME, "Makefile");
unless (open(MK, ">" . $makefile)) {
        cleanup($ds, 1, "Failed to open $makefile for writing: $!\n");
}
foreach my $key (keys %pkgdir) {
        my @depsarr = @{$pkgdeps{$key}};
        my @deppkgnames = map { $pkgdir{$_} . $ENV{'PKGSUFFIX'} } @depsarr;
        print MK "all: $pkgdir{$key}$ENV{'PKGSUFFIX'}\n";
        print MK "$pkgdir{$key}: $pkgdir{$key}$ENV{'PKGSUFFIX'}\n";
        print MK "$pkgdir{$key}$ENV{'PKGSUFFIX'}: "
            . join(" ", @deppkgnames) . "\n";
        print MK
            "\t\@$PORTBUILD $BUILD_NAME $JAIL_NAME $PORTSTREE_NAME $pkgdir{$key}$ENV{'PKGSUFFIX'} /usr/ports/$key "
            . join(" ", @deppkgnames) . "\n";
}
close(MK);

# Now, symlink the Makefile to the correct All directory.
system("mkdir -p $BUILD_ROOT/packages/$BUILD_NAME/All");
symlink $makefile, "$BUILD_ROOT/packages/$BUILD_NAME/All/Makefile";

cleanup($ds, 0, undef);
