#!/usr/bin/perl
#-
# Copyright (c) 2004-2005 FreeBSD GNOME Team <freebsd-gnome@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $MCom: portstools/tinderbox/makemake,v 1.30 2005/07/11 19:58:28 marcus Exp $
#

# Handle being called from a directory other than where things
# 'normally' reside
BEGIN {
        my $scripts;
        if ($0 !~ m|/|) {
                $scripts = '.';
        } else {
                $scripts = $0;
                $scripts =~ s|/[^/]+$||;
        }
        push @INC, $scripts;
        require lib;
        import lib $scripts;
}

use strict;
use TinderboxDS;
use Getopt::Std;
use File::Path;
use vars qw(
    $BUILD
    $BUILD_NAME
    $JAIL
    $JAIL_NAME
    $PORTSTREE
    $PORTSTREE_NAME
    @PORTS
    $BUILD_ROOT
    $PORTBUILD
);

require "tinderbox.ph";    # Setup the tinderbox config.
require "tinderlib.pl";

# Get a database handle for obtaining the ports.
my $ds          = new TinderboxDS();
my @build_names = $ds->getAllBuilds();

if (!@build_names && defined($ds->getError())) {
        cleanup($ds, 1,
                "Failed to get list of jails: " . $ds->getError() . "\n");
} elsif (!@build_names) {
        cleanup($ds, 1, "There are no builds configured in this tinderbox\n");
}

if (scalar(@ARGV) < 1) {
        print STDERR "usage: $0 [-n] <build name> [<port directory> ...]\n";
        print STDERR "Current builds are:\n";
        foreach (@build_names) {
                print STDERR "\t" . $_->getName() . "\n";
        }
        cleanup($ds, 1, undef);
}

my $opts;
getopts('n', $opts);
my $noduds = $opts->{'n'} ? 1 : 0;

my @flarr;
push @flarr, "-noclean"    if (defined($ENV{'NOCLEAN'}));
push @flarr, "-plistcheck" if (defined($ENV{'PLISTCHECK'}));
push @flarr, "-nullfs"     if (defined($ENV{'NULLFS'}));
my $pbflags = join(" ", @flarr);

@PORTS = ();
$BUILD = $ds->getBuildByName($ARGV[0]);
if (!$BUILD) {
        cleanup($ds, 1, "Unknown build, \"$ARGV[0]\"\n");
}
$BUILD_NAME = $BUILD->getName();
shift @ARGV;

$JAIL           = $ds->getJailForBuild($BUILD);
$JAIL_NAME      = $JAIL->getName();
$PORTSTREE      = $ds->getPortsTreeForBuild($BUILD);
$PORTSTREE_NAME = $PORTSTREE->getName();

#---------------------------------------------------------------------------
# Set up the environment, including a few bogus values to prevent
# system-installed packages from affecting the tinderbox run.
#---------------------------------------------------------------------------

buildenv($BUILD_ROOT, $BUILD_NAME, $JAIL_NAME, $PORTSTREE_NAME);

delete $ENV{'DISPLAY'};
$ENV{'LOCALBASE'}  = "/nonexistentlocal";
$ENV{'X11BASE'}    = "/nonexistentx";
$ENV{'PKG_DBDIR'}  = "/nonexistentdb";
$ENV{'PORT_DBDIR'} = "/nonexistentportdb";
$ENV{'LINUXBASE'}  = "/nonexistentlinux";

#---------------------------------------------------------------------------
# Handle either ports on the command line, or configured ports for
# a particular build
#---------------------------------------------------------------------------

if (!scalar(@ARGV)) {
        my @dsPorts = $ds->getPortsForBuild($BUILD);
        if (!@dsPorts) {
                cleanup($ds, 1,
                              "Failed to get port information: "
                            . $ds->getError()
                            . "\n");
        }
        push @PORTS, @dsPorts;

} else {
        foreach my $arg (@ARGV) {
                my $port = $ds->getPortByDirectory($arg);
                if (!$port) {

                        # Simply create a sparse port with just a directory.
                        # If the port doesn't exist in the datastore, that's
                        # okay.
                        $port = new Port();
                        $port->setDirectory($arg);
                        push @PORTS, $port;
                } else {
                        push @PORTS, $port
                            if $ds->isPortForBuild($port, $BUILD);
                }
        }
}

#---------------------------------------------------------------------------
# Main loop.  Process all the ports, and their dependencies
#---------------------------------------------------------------------------

my (
        %pkgdir,   %pkgdeps,  %pkgedeps, %pkgpdeps, %pkgfdeps,
        %pkgbdeps, %pkgrdeps, @duds,     %makecache
);

while (scalar(@PORTS)) {
        my $port    = shift @PORTS;
        my $portdir = $port->getDirectory();
        my ($pkgname, $deplist, $tportdir);

        next if (defined($pkgdir{$portdir}));

        $tportdir = $ENV{'PORTSDIR'} . "/" . $portdir;
        if (!-d $tportdir) {
                print STDERR "ERROR: Directory $tportdir does not exist.\n";
                if (defined($pkgdeps{$portdir})
                        && scalar(@{$pkgdeps{$portdir}}))
                {
                        print STDERR "ERROR: It is referenced by "
                            . (join(" ", @{$pkgdeps{$portdir}})) . "\n";
                }
                cleanup($ds, 1, undef);
        }
        $pkgname = getPortPkgName($portdir, \%makecache);

        # Create a list of duds (ports that will not be attempted because they
        # are marked IGNORE or FORBIDDEN).
        if (!$noduds) {
                my $dudpkg = getPortIgnoreList($portdir, \%makecache);
                push @duds, $dudpkg if ($dudpkg);
        }

        my (@edeps, @pdeps, @fdeps, @bdeps, @rdeps) = ();
        $pkgdeps{$portdir}  = [];
        $pkgedeps{$portdir} = [];
        $pkgpdeps{$portdir} = [];
        $pkgfdeps{$portdir} = [];
        $pkgbdeps{$portdir} = [];
        $pkgrdeps{$portdir} = [];
        $pkgdir{$portdir}   = $pkgname;
        push @edeps, getPortExtractDepends($portdir, \%makecache);
        push @pdeps, getPortPatchDepends($portdir, \%makecache);
        push @fdeps, getPortFetchDepends($portdir, \%makecache);
        push @bdeps, getPortBuildDependsList($portdir, \%makecache);
        push @rdeps, getPortRunDependsList($portdir, \%makecache);

        findRunDepends(\@edeps, \%pkgedeps, $portdir, \%makecache, \@PORTS);
        findRunDepends(\@pdeps, \%pkgpdeps, $portdir, \%makecache, \@PORTS);
        findRunDepends(\@fdeps, \%pkgfdeps, $portdir, \%makecache, \@PORTS);
        findRunDepends(\@bdeps, \%pkgbdeps, $portdir, \%makecache, \@PORTS);
        findRunDepends(\@rdeps, \%pkgrdeps, $portdir, \%makecache, \@PORTS);

        foreach my $depport (
                @{$pkgedeps{$portdir}}, @{$pkgpdeps{$portdir}},
                @{$pkgfdeps{$portdir}}, @{$pkgbdeps{$portdir}},
                @{$pkgrdeps{$portdir}}
            )
        {
                if (defined($depport) && $depport ne "") {
                        push @{$pkgdeps{$portdir}}, $depport;
                }
        }
}

#---------------------------------------------------------------------------
# Write out Makefile and duds file
# Symlink Makefile to the correct 'All' directory
#---------------------------------------------------------------------------

my $builddir = $BUILD_ROOT . '/builds/' . $BUILD_NAME;

cleanup($ds, 1, "Failed to open $builddir makefile for writing: $!\n")
    unless (open(MK, "> $builddir/Makefile"));

foreach my $key (keys %pkgdir) {
        my $pname    = $pkgdir{$key} . $ENV{'PKGSUFFIX'};
        my $pkgnames = makeList(\%pkgdir, 1, \%makecache, @{$pkgdeps{$key}});
        my $edeplst  = makeList(\%pkgdir, 0, \%makecache, @{$pkgedeps{$key}});
        my $pdeplst  = makeList(\%pkgdir, 0, \%makecache, @{$pkgpdeps{$key}});
        my $fdeplst  = makeList(\%pkgdir, 0, \%makecache, @{$pkgfdeps{$key}});
        my $bdeplst  = makeList(\%pkgdir, 0, \%makecache, @{$pkgbdeps{$key}});
        my $rdeplst  = makeList(\%pkgdir, 0, \%makecache, @{$pkgrdeps{$key}});

        printf MK "all: %s\n",          $pname;
        printf MK "%s: %s\n",           $pkgdir{$key}, $pname;
        printf MK "%s: %s\n",           $pname, $pkgnames;
        printf MK "\t@%s %s %s %s %s ", $PORTBUILD, $BUILD_NAME, $JAIL_NAME,
            $PORTSTREE_NAME, $pbflags;
        printf MK "\"%s\" \"%s\" \"%s\" \"%s\" \"%s\" ", $edeplst, $pdeplst,
            $fdeplst, $bdeplst, $rdeplst;
        printf MK "%s /usr/ports/%s\n", $pname, $key;
}

close(MK);

unlink("$builddir/duds");
if (!$noduds) {
        cleanup($ds, 1, "Failed to open $builddir duds for writing: $!\n")
            unless (open(DUDS, "> $builddir/duds"));
        foreach my $dud (sort @duds) {
                printf DUDS "%s\n", $dud;
        }
        close(DUDS);
}

my $pkgdir = $BUILD_ROOT . '/packages/' . $BUILD_NAME . '/All';
mkpath $pkgdir;
symlink "$builddir/Makefile", "$pkgdir/Makefile";

#---------------------------------------------------------------------------
# And finish up
#---------------------------------------------------------------------------

cleanup($ds, 0, undef);

#---------------------------------------------------------------------------
# A few subroutines used in the main loop
#---------------------------------------------------------------------------

sub uniqueList {
        my %seen;
        my @uniq = grep { !$seen{$_}++ } @_;
        return @uniq;
}

sub makeList {
        my $pkgdir = shift;
        my $douniq = shift;
        my $cache  = shift;
        my $list   = join(' ',
                map { $pkgdir{$_} . $ENV{'PKGSUFFIX'} }
                    $douniq eq 1 ? uniqueList(@_) : @_);
        return $list;
}

sub findRunDepends {
        my $source    = shift;
        my $dest      = shift;
        my $portdir   = shift;
        my $makecache = shift;
        my $ports     = shift;

        foreach my $rdep (@{$source}) {
                next if ($rdep eq "");
                my %seen = ();
                my @rundeps = getPortRunDependsList($rdep, $makecache);
                while (scalar(@rundeps)) {
                        my $rundep = shift @rundeps;
                        next if (defined($seen{$rundep}));
                        next if ($rundep eq "");
                        push @rundeps,
                            getPortRunDependsList($rundep, $makecache);
                        $seen{$rundep}++;
                        push @{$dest->{$portdir}}, $rundep;
                }
                push @{$dest->{$portdir}}, $rdep;
                my $p = new Port();
                $p->setDirectory($rdep);
                push @{$ports}, $p;
        }
}

#---------------------------------------------------------------------------
# Cached make(1) implementation:  Ade Lovett <ade@FreeBSD.org>
#---------------------------------------------------------------------------

sub getPortInfo {
        my $port  = shift;
        my $cache = shift;
        my @ret;
        my $tmp;

        # list of variables we're going to pull from the port Makefile
        my @makeTargets = (
                'PKGNAME',         'IGNORE',
                'NO_PACKAGE',      'FORBIDDEN',
                'EXTRACT_DEPENDS', 'PATCH_DEPENDS',
                'FETCH_DEPENDS',   'BUILD_DEPENDS',
                'LIB_DEPENDS',     'RUN_DEPENDS',
                'DEPENDS'
        );

        return if ($cache->{$port}{'didmake'} eq 1);

        $tmp = '-V ' . join(' -V ', @makeTargets);
        @ret = split("\n", `cd $ENV{'PORTSDIR'}/$port && make $tmp`);

        foreach $tmp (@makeTargets) {
                $cache->{$port}{$tmp} = shift @ret;
        }
        $cache->{$port}{'didmake'} = 1;
}

# Return the port package name
sub getPortPkgName {
        my $port  = shift;
        my $cache = shift;

        getPortInfo($port, $cache);
        return $cache->{$port}{'PKGNAME'};
}

# General function for returning a port dependency list
sub getPortDepends {
        my $port  = shift;
        my $cache = shift;
        my $item  = shift;

        getPortInfo($port, $cache);

        my @deps = ();
        foreach my $dep (split(/\s+/, $cache->{$port}{$item})) {
                my ($d, $ddir) = split(/:/, $dep);
                $ddir =~ s|^$ENV{'PORTSDIR'}/||;
                push @deps, $ddir;
        }

        return @deps;
}

sub getPortExtractDepends {
        my $port  = shift;
        my $cache = shift;
        return getPortDepends($port, $cache, 'EXTRACT_DEPENDS');
}

sub getPortPatchDepends {
        my $port  = shift;
        my $cache = shift;
        return getPortDepends($port, $cache, 'PATCH_DEPENDS');
}

sub getPortFetchDepends {
        my $port  = shift;
        my $cache = shift;
        return getPortDepends($port, $cache, 'FETCH_DEPENDS');
}

sub getPortBuildDepends {
        my $port  = shift;
        my $cache = shift;
        return getPortDepends($port, $cache, 'BUILD_DEPENDS');
}

sub getPortLibDepends {
        my $port  = shift;
        my $cache = shift;
        return getPortDepends($port, $cache, 'LIB_DEPENDS');
}

sub getPortRunDepends {
        my $port  = shift;
        my $cache = shift;
        return getPortDepends($port, $cache, 'RUN_DEPENDS');
}

sub getPortOtherDepends {
        my $port  = shift;
        my $cache = shift;
        return getPortDepends($port, $cache, 'DEPENDS');
}

# A close approximation to the 'ignore-list' target
sub getPortIgnoreList {
        my $port  = shift;
        my $cache = shift;
        my $n     = 0;

        getPortInfo($port, $cache);
        foreach my $tmp ('NO_PACKAGE', 'IGNORE', 'FORBIDDEN') {
                $n++ if ($cache->{$port}{$tmp} ne "");
        }

        return $n eq 0 ? "" : getPortPkgName($port, $cache);
}

# A close approximation to the 'build-depends-list' target
sub getPortBuildDependsList {
        my $port  = shift;
        my $cache = shift;
        my @deps;

        push @deps, getPortExtractDepends($port, $cache);
        push @deps, getPortPatchDepends($port, $cache);
        push @deps, getPortFetchDepends($port, $cache);
        push @deps, getPortBuildDepends($port, $cache);
        push @deps, getPortLibDepends($port, $cache);
        push @deps, getPortOtherDepends($port, $cache);
        return uniqueList(@deps);
}

# A close approximation to the 'run-depends-list' target
sub getPortRunDependsList {
        my $port  = shift;
        my $cache = shift;
        my @deps;

        push @deps, getPortLibDepends($port, $cache);
        push @deps, getPortRunDepends($port, $cache);
        push @deps, getPortOtherDepends($port, $cache);
        return uniqueList(@deps);
}
