#!/usr/bin/perl

use strict;
use TinderboxDS;
use vars qw(
    $JAIL
    $JAIL_NAME
    @PORTS
    $JAIL_REPO
    $BUILD_ROOT
    $PORTBUILD
    $ERROR_DIR
    $LOG_DIR
    $SERVER_PROTOCOL
    $SERVER_HOST
    $SERVER_DIR
    $SENDMAIL
    $SENDER
    $SUBJECT
    $TINDER_STOP
);

require "tinderbox.ph";    # Setup the tinderbox config.
require "buildenv.pl";

# Get a database handle for obtaining the ports.
my $ds         = new TinderboxDS();
my @jail_names = $ds->getAllJails();
if (!defined(@jail_names) && defined($ds->getError())) {
        cleanup($ds, 1,
                "Failed to get list of jails: " . $ds->getError() . "\n");
} elsif (!defined(@jail_names)) {
        cleanup($ds, 1, "There are no jails configured in this tinderbox\n");
}
if (scalar(@ARGV) < 1) {
        print STDERR
            "usage: tinderbuild <jail name> [<portname> <port directory> ...]\n";
        print STDERR "Current jails are:\n";
        foreach (@jail_names) {
                print STDERR "\t" . $_->getName() . "\n";
        }
        cleanup($ds, 1, undef);
}

@PORTS = ();
$JAIL  = $ds->getJailByName($ARGV[0]);
if (!$JAIL) {
        cleanup($ds, 1, "Unknown jail $ARGV[0]\n");
}
$JAIL_NAME = $JAIL->getName();
shift @ARGV;

buildenv($BUILD_ROOT, $JAIL_NAME);

if (!scalar(@ARGV)) {
        my @dsPorts = $ds->getAllPorts();
        if (!defined(@dsPorts)) {
                cleanup($ds, 1,
                              "Failed to get port information: "
                            . $ds->getError()
                            . "\n");
        }
        foreach my $port (@dsPorts) {
                push @PORTS, $port
                    if $ds->isPortForJail($port, $JAIL);
        }
} else {
        foreach my $arg (@ARGV) {
                my $port = $ds->getPortByDirectory($arg);
                if (!$port) {

                        # Simply create a sparse port with just a directory.
                        # If the port doesn't exist in the datastore, that's
                        # okay.
                        $port = new Port({Directory => $arg});
                        push @PORTS, $port;
                } else {
                        push @PORTS, $port if $ds->isPortForJail($port, $JAIL);
                }
        }
}
my (%pkgdir, %pkgdeps);
while (scalar(@PORTS)) {
        my $port    = shift @PORTS;
        my $portdir = $port->getDirectory();
        my ($pkgname, $deplist, $tportdir, @deps);

        next if (defined($pkgdir{$portdir}));

        $tportdir = $ENV{'PORTSDIR'} . "/" . $portdir;
        $pkgname  = `cd $tportdir && make -V PKGNAME`;
        chomp $pkgname;

        $pkgdeps{$portdir} = [];
        $pkgdir{$portdir}  = $pkgname;
        $deplist           = `cd $tportdir && make all-depends-list`;
        chomp $deplist;
        @deps = split(/\n/, $deplist);
        foreach my $dep (@deps) {
                $dep =~ s|^$ENV{'PORTSDIR'}/||;
                push @{$pkgdeps{$portdir}}, $dep;
                push @PORTS, (new Port({Directory => $dep}));
        }
}
my $makefile = join("/", $BUILD_ROOT, "Makefile." . $JAIL);
unless (open(MK, ">" . $makefile)) {
        cleanup($ds, 1, "Failed to open $makefile for writing: $!\n");
}
foreach my $key (keys %pkgdir) {
        my @depsarr = @{$pkgdeps{$key}};
        my @deppkgnames = map { $pkgdir{$_} . $ENV{'PKGSUFFIX'} } @depsarr;
        print MK "all: $pkgdir{$key}$ENV{'PKGSUFFIX'}\n";
        print MK "$pkgdir{$key}: $pkgdir{$key}$ENV{'PKGSUFFIX'}\n";
        print MK "$pkgdir{$key}$ENV{'PKGSUFFIX'}: "
            . join(" ", @deppkgnames) . "\n";
        print MK
            "\t\@$PORTBUILD $JAIL_NAME $pkgdir{$key}$ENV{'PKGSUFFIX'} /usr/ports/$key "
            . join(" ", @deppkgnames) . "\n";
}
close(MK);

# Now, symlink the Makefile to the correct All directory.
system("mkdir -p $BUILD_ROOT/packages/$JAIL_NAME/All");
symlink $makefile, "$BUILD_ROOT/packages/$JAIL_NAME/All/Makefile";

cleanup($ds, 0, undef);

sub cleanup {
        my ($ds, $code, $msg) = @_;

        if ($code && defined($msg)) {
                $msg = "ERROR: " . $msg;
        } elsif (defined($msg)) {
                $msg = "INFO: " . $msg;
        }

        $ds->destroy()    if (defined($ds));
        print STDERR $msg if (defined($msg));

        exit($code);
}
