#!/bin/sh

pb=/space

usage () {
    echo "usage: $0 -b <build name> [-init] [-cleanpackages] [-updateports] [portdir/portname [...]]"
}

. ${pb}/scripts/buildenv

_builds=$(${pb}/scripts/tc listBuilds)
build=""
ports=""

init=0
cleanpackages=0
updateports=0

while [ $# -gt 0 ]; do
    case "x$1" in
      x-b)
        shift
        if echo ${_builds} | grep -qw "$1"; then
	    build=$1
	else
	    echo "ERROR: Build, \"$1\" is not a valid build."
	    exit 1
	fi
	;;
      x-init)
        init=1
	;;
      x-updateports)
        updateports=1
	;;
      x-cleanpackages)
        cleanpackages=1
	;;
      -*)
        usage
	;;
      *)
        ports="${ports} $1"
	;;
    esac
    shift
done

if [ "x${build}" = "x" ]; then
    usage
    exit 1
fi

jail=$(${pb}/scripts/tc getJailForBuild -b ${build})
portstree=$(${pb}/scripts/tc getPortsTreeForBuild -b ${build})

# Setup the environment for this jail.
buildenv ${pb} ${build} ${jail} ${portstree}

# Remove the make logs.
rm -f ${pb}/builds/${build}/make.*

# First we check to see if we need to clean out old packages.
if [ "$cleanpackages" = "1" ]; then
    rm -rf ${PACKAGES}
fi

mkdir -p ${PACKAGES}

if [ "$updateports" = "1" ]; then
    update_cmd=$(${pb}/scripts/tc getPortsUpdateCmd -p ${portstree})
    if [ ! -z "${update_cmd}" ]; then
	echo "INFO: Running ${update_cmd} to update the ports tree"
	eval ${update_cmd} >/dev/null 2>&1
    fi
fi

# Next, we build a Makefile for each jail.
${pb}/scripts/makemake ${build} ${ports}

if [ $? != 0 ]; then
    echo "ERROR: Failed to generate Makefile for ${build}"
    exit 1
fi

# Then we check to see if we need to create our jail directory.
if [ "$init" = "1" -o \( ! -d ${pb}/${build} -a ! -f ${pb}/jails/${jail}/${jail}.tar \) ]; then
    echo "INFO: Initializing a new build directory for ${build}..."
    ${pb}/scripts/mkjail ${jail}
    ${pb}/scripts/mkbuild ${build}
elif [ ! -d ${pb}/${build} -a -f ${pb}/jails/${jail}/${jail}.tar ]; then
    echo "INFO: Creating build directory for ${build} from repository..."
    ${pb}/scripts/mkbuild ${build}
fi

# We do this in two phases to make sure we get everything.
echo "================================================"
echo "building packages (phase 1)"
echo "================================================"
echo "started at $(date)"
phase1start=$(date +%s)
cd ${PACKAGES}/All && make -k -j1 all > ${pb}/builds/${build}/make.0 2>&1 </dev/null
echo "ended at $(date)"
phase1end=$(date +%s)
echo "phase 1 took $(date -u -j -r $(($phase1end - $phase1start)) | awk '{print $4}')" 
echo $(echo $(ls -1 ${PACKAGES}/All/*${PKGSUFFIX} | wc -l) | bc) "packages built"
echo $(echo $(du -sh ${PACKAGES} | awk '{print $1}')) " of packages"

echo "================================================"
echo "building packages (phase 2)"
echo "================================================"
echo "started at $(date)"
phase2start=$(date +%s)
cd ${PACKAGES}/All && make -k -j1 all > ${pb}/builds/${build}/make.1 2>&1 </dev/null
echo "ended at $(date)"
phase2end=$(date +%s)
echo "phase 2 took $(date -u -j -r $(($phase2end - $phase2start)) | awk '{print $4}')"
echo $(echo $(ls -1 ${PACKAGES}/All/*${PKGSUFFIX} | wc -l) | bc) "packages built"
echo $(echo $(du -sh ${PACKAGES} | awk '{print $1}')) " of packages"

exit 0
