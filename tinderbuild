#!/bin/sh
#-
# Copyright (c) 2004 FreeBSD GNOME Team <freebsd-gnome@FreeBSD.org>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
# $Id$
#


cleanup() {
    pb=$1
    build=$2
    lock=$3
    error=$4

    rm -f ${lock}
    ${pb}/scripts/tc updateBuildStatus -b ${build} -s IDLE

    exit ${error}
}

pb=/space

usage () {
    echo "usage: $0 -b <build name> [-init] [-cleanpackages] [-updateports] [-skipmake] [portdir/portname [...]]"
}

. ${pb}/scripts/buildenv

_builds=$(${pb}/scripts/tc listBuilds)
build=""
ports=""

init=0
cleanpackages=0
updateports=0
skipmake=0
skipmake=0
error=2

while [ $# -gt 0 ]; do
    case "x$1" in
      x-b)
        shift
        if echo ${_builds} | grep -qw "$1"; then
	    build=$1
	else
	    echo "ERROR: Build, \"$1\" is not a valid build."
	    exit 1
	fi
	;;
      x-init)
        init=1
	;;
      x-updateports)
        updateports=1
	;;
      x-cleanpackages)
        cleanpackages=1
	;;
      x-skipmake)
        skipmake=1
	;;
      -*)
        usage
	;;
      *)
        ports="${ports} $1"
	;;
    esac
    shift
done

if [ "x${build}" = "x" ]; then
    usage
    exit 1
fi

lock=${pb}/builds/${build}/lock

if [ -e ${lock} ]; then
    echo "ERROR: Lock file ${lock} exists; exiting."
    exit 1
fi

touch ${lock}

# Let the datastore known what we're doing.
${pb}/scripts/tc updateBuildStatus -b ${build} -s PREPARE

trap "cleanup ${pb} ${build} ${lock} ${error}" 1 2 3 9 10 11 15

# XXX This is a crude hack to normalize ${ports}
ports=$(echo ${ports})

jail=$(${pb}/scripts/tc getJailForBuild -b ${build})
portstree=$(${pb}/scripts/tc getPortsTreeForBuild -b ${build})

# Setup the environment for this jail.
buildenv ${pb} ${build} ${jail} ${portstree}

# Remove the make logs.
rm -f ${pb}/builds/${build}/make.*

# First we check to see if we need to clean out old packages.
if [ "$cleanpackages" = "1" ]; then
    rm -rf ${PACKAGES}
    rm -rf ${pb}/logs/${build}
    rm -rf ${pb}/errors/${build}
fi

mkdir -p ${PACKAGES}
mkdir -p ${pb}/logs/${build}
mkdir -p ${pb}/errors/${build}

if [ "$updateports" = "1" ]; then
    echo "INFO: Running ${update_cmd} to update the ports tree"
    ${pb}/scripts/tc updatePortsTree -p ${portstree}
fi

if [ "$skipmake" = "0" ]; then
    # Next, we build a Makefile for each jail.
    ${pb}/scripts/makemake ${build} ${ports}

    if [ $? != 0 ]; then
        echo "ERROR: Failed to generate Makefile for ${build}"
        cleanup ${pb} ${build} ${lock} 1
    fi
fi

# Then we check to see if we need to create our jail directory.
if [ "$init" = "1" -o \( ! -d ${pb}/${build} -a ! -f ${pb}/jails/${jail}/${jail}.tar \) ]; then
    echo "INFO: Initializing a new build directory for ${build}..."
    ${pb}/scripts/mkjail ${jail}
    ${pb}/scripts/mkbuild ${build}
else
    echo "INFO: Creating build directory for ${build} from repository..."
    ${pb}/scripts/mkbuild ${build}
fi

${pb}/scripts/tc updateBuildStatus -b ${build} -s PORTBUILD

# We do this in two phases to make sure we get everything.
echo "================================================"
echo "building packages (phase 1)"
echo "================================================"
echo "started at $(date)"
phase1start=$(date +%s)
cd ${PACKAGES}/All && make -k -j1 all > ${pb}/builds/${build}/make.0 2>&1 </dev/null
echo "ended at $(date)"
phase1end=$(date +%s)
echo "phase 1 took $(date -u -j -r $(($phase1end - $phase1start)) | awk '{print $4}')"
echo $(echo $(ls -1 ${PACKAGES}/All/*${PKGSUFFIX} | wc -l) | bc) "packages built"
echo $(echo $(du -sh ${PACKAGES} | awk '{print $1}')) " of packages"

echo "================================================"
echo "building packages (phase 2)"
echo "================================================"
echo "started at $(date)"
phase2start=$(date +%s)
cd ${PACKAGES}/All && make -k -j1 all > ${pb}/builds/${build}/make.1 2>&1 </dev/null
echo "ended at $(date)"
phase2end=$(date +%s)
echo "phase 2 took $(date -u -j -r $(($phase2end - $phase2start)) | awk '{print $4}')"
echo $(echo $(ls -1 ${PACKAGES}/All/*${PKGSUFFIX} | wc -l) | bc) "packages built"
echo $(echo $(du -sh ${PACKAGES} | awk '{print $1}')) " of packages"

cleanup ${pb} ${build} ${lock} 0
